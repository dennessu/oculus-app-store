package com.junbo.identity.rest.resource.v1

import com.junbo.common.id.PITypeId
import com.junbo.common.model.Results
import com.junbo.common.rs.Created201Marker
import com.junbo.identity.core.service.filter.PITypeFilter
import com.junbo.identity.core.service.validator.PITypeValidator
import com.junbo.identity.service.PITypeService
import com.junbo.identity.spec.error.AppErrors
import com.junbo.identity.spec.v1.model.PIType
import com.junbo.identity.spec.v1.option.list.PITypeListOptions
import com.junbo.identity.spec.v1.option.model.PITypeGetOptions
import com.junbo.identity.spec.v1.resource.PITypeResource
import com.junbo.langur.core.promise.Promise
import groovy.transform.CompileStatic
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.transaction.annotation.Transactional

import javax.ws.rs.core.Response

/**
 * Created by haomin on 14-4-25.
 */
@Transactional
@CompileStatic
class PITypeResourceImpl implements PITypeResource {
    @Autowired
    private PITypeService piTypeService

    @Autowired
    private PITypeFilter piTypeFilter

    @Autowired
    private PITypeValidator piTypeValidator

    @Override
    Promise<PIType> create(PIType piType) {
        if (piType == null) {
            throw new IllegalArgumentException('piType is null')
        }

        piType = piTypeFilter.filterForCreate(piType)

        return piTypeValidator.validateForCreate(piType).then {
            // preset pitype.id to avoiding random id generated by repository
            // pitype.id should consistent with enum PIType definition
            com.junbo.common.id.PIType piTypeEnum = Enum.valueOf(com.junbo.common.id.PIType, piType.typeCode)
            piType.id = new PITypeId(piTypeEnum.id)

            return piTypeService.create(piType).then { PIType newPIType ->
                Created201Marker.mark(newPIType.id)
                newPIType = piTypeFilter.filterForGet(newPIType, null)
                return Promise.pure(newPIType)
            }
        }
    }

    @Override
    Promise<PIType> put(PITypeId piTypeId, PIType piType) {
        if (piTypeId == null) {
            throw new IllegalArgumentException('piTypeId is null')
        }

        if (piType == null) {
            throw new IllegalArgumentException('piType is null')
        }

        return piTypeService.get(piTypeId).then { PIType oldPIType ->
            if (oldPIType == null) {
                throw AppErrors.INSTANCE.piTypeNotFound(piTypeId).exception()
            }

            piType = piTypeFilter.filterForPut(piType, oldPIType)

            return piTypeValidator.validateForUpdate(piTypeId, piType, oldPIType).then {
                return piTypeService.update(piType, oldPIType).then { PIType newPIType ->
                    newPIType = piTypeFilter.filterForGet(newPIType, null)
                    return Promise.pure(newPIType)
                }
            }
        }
    }

    @Override
    Promise<PIType> patch(PITypeId piTypeId, PIType piType) {
        if (piTypeId == null) {
            throw new IllegalArgumentException('piTypeId is null')
        }

        if (piType == null) {
            throw new IllegalArgumentException('piType is null')
        }

        return piTypeService.get(piTypeId).then { PIType oldPIType ->
            if (oldPIType == null) {
                throw AppErrors.INSTANCE.piTypeNotFound(piTypeId).exception()
            }

            piType = piTypeFilter.filterForPatch(piType, oldPIType)

            return piTypeValidator.validateForUpdate(piTypeId, piType, oldPIType).then {
                return piTypeService.update(piType, oldPIType).then { PIType newPIType ->
                    newPIType = piTypeFilter.filterForGet(newPIType, null)
                    return Promise.pure(newPIType)
                }
            }
        }
    }

    @Override
    Promise<PIType> get(PITypeId piTypeId, PITypeGetOptions getOptions) {
        if (getOptions == null) {
            throw new IllegalArgumentException('getOptions is null')
        }

        return piTypeValidator.validateForGet(piTypeId).then {
            return piTypeService.get(piTypeId).then { PIType newPIType ->
                if (newPIType == null) {
                    throw AppErrors.INSTANCE.piTypeNotFound(piTypeId).exception()
                }

                newPIType = piTypeFilter.filterForGet(newPIType, getOptions.properties?.split(',') as List<String>)
                return Promise.pure(newPIType)
            }
        }
    }

    @Override
    Promise<Results<PIType>> list(PITypeListOptions listOptions) {
        if (listOptions == null) {
            throw new IllegalArgumentException('listOptions is null')
        }

        return piTypeValidator.validateForSearch(listOptions).then {
            return search(listOptions).then { List<PIType> piTypeList ->
                def result = new Results<PIType>(items: [])

                piTypeList.each { PIType newPItype ->
                    newPItype = piTypeFilter.filterForGet(newPItype, null)

                    if (newPItype != null) {
                        result.items.add(newPItype)
                    }
                }

                return Promise.pure(result)
            }
        }
    }

    @Override
    Promise<Response> delete(PITypeId piTypeId) {
        if (piTypeId != null) {
            throw new IllegalArgumentException('piTypeId is null')
        }

        return piTypeValidator.validateForGet(piTypeId).then {
            return piTypeService.delete(piTypeId).then {
                return Promise.pure(Response.status(204).build())
            }
        }
    }

    private Promise<List<PIType>> search(PITypeListOptions listOptions) {
        if (listOptions.typeCode != null) {
            return piTypeService.searchByTypeCode(listOptions.typeCode, listOptions.limit, listOptions.offset)
        } else {
            return piTypeService.searchAll(listOptions.limit, listOptions.offset)
        }
    }
}
