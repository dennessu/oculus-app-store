input {
  file {
    path => [ "/var/silkcloud/logs/main.log" ]
    codec => multiline {
      pattern => "^\["
      what => "previous"
      negate => true
    }
    type => "main_log"
    start_position => beginning
    stat_interval => 10
  }

  file {
    path => [ "/var/silkcloud/logs/httpd.log" ]
    type => "httpd_log"
    start_position => beginning
    stat_interval => 10
  }
}

filter {
  if [type] == "main_log" {
    grok {
      match => {
        "message" => "(?m)\[%{DATA:timestamp}\]%{SPACE}%{WORD:severity}%{SPACE}%{INT:pid}%{SPACE}\[%{SPACE}%{DATA:thread}\]%{SPACE}\[%{SPACE}%{DATA:requestid}\]%{GREEDYDATA:message}"
      }
      overwrite => [ "message" ]
    }
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS Z" ]
      remove_field => [ "timestamp" ]
    }
  } else if [type] == "httpd_log" {
    grok {
      match => {
        "message" => "(?:%{IPORHOST:clientip}|-) %{INT:response_time} %{USER:auth} \[%{DATA:timestamp}\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response_code} (?:%{NUMBER:bytes}|-) \"%{DATA:referer}\" \"%{DATA:user_agent}\" \[%{SPACE}%{DATA:requestid}\]"
      }
    }
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS Z" ]
      remove_field => [ "timestamp" ]
    }
    mutate { remove_field => [ "message" ] }
  } else {
    mutate { replace => { type => "random_log" } }
  }
}

output {
  stdout { }
  redis {
    host => "10.200.108.30"
    data_type => "list"
    key => "logstash"
  }
}
